Instructions Your task is to implement a simplified version of an in-memory database. All operations that should be supported by this database are described below. Solving this task consists of several levels. Subsequent levels are opened when the current level is correctly solved. You always have access to the data for the current and all previous levels. You are not required to provide the most efficient implementation. Any code that passes the unit tests is sufficient. You can execute a single test case by running the following command in the terminal: bash run_single_test.sh "<test_case_name>". Requirements Your task is to implement a simplified version of an in-memory database. Plan your design according to the level specifications below: Level 1: In-memory database should support basic operations to manipulate records, fields, and values within fields. Level 2: In-memory database should support displaying a record's fields based on a filter. Level 3: In-memory database should support the TTL (Time-To-Live) settings for records. Level 4: In-memory database should support look-back operations to retrieve values stored at a specific timestamp in the past. To move to the next level, you need to pass all the tests at this level when submitting the solution. Level 1 The basic level of the in-memory database contains records. Each record can be accessed with a unique identifier key, which is of string type. A record contains several field-value pairs, with field as string type and value as integer type. All operations have a timestamp parameter — a stringified timestamp in milliseconds. It is guaranteed that all timestamps are unique and are in a range from 1 to 109. Operations will be given in order of strictly increasing timestamps. Timestamps will be needed starting from Level 3. set(self, timestamp: int, key: str, field: str, value: int) -> None — should insert a field-value pair to the record associated with key. If the field in the record already exists, replace the existing value with the specified value. If the record does not exist, a new one is created. compare_and_set(self, timestamp: int, key: str, field: str, expected_value: int, new_value: int) -> bool — should update the value of field in the record associated with key to new_value if the current value equals expected_value. If expected_value does not match the current value, or either key or field does not exist, this operation is ignored. This operation should return True if the field was updated and False otherwise. compare_and_delete(self, timestamp: int, key: str, field: str, expected_value: int) -> bool — should remove the field field in the record associated with key if the previous value equals expected_value. If expected_value does not match the current value, or either key or field does not exist, this operation is ignored. This operation should return True if the field was removed and False otherwise. get(self, timestamp: int, key: str, field: str) -> int | None — should return the value contained within field of the record associated with key. If the record or the field does not exist, should return None. Examples The example below shows how these operations should work (the section is scrollable to the right): Queries Explanations set(0, "A", "B", 4) set(1, "A", "C", 6) compare_and_set(2, "A", "B", 4, 9) compare_and_set(3, "A", "C", 4, 9) compare_and_delete(4, "A", "C", 6) get(5, "A", "C") get(6, "A", "B") database state: {"A": {"B": 4}} database state: {"A": {"B": 4, "C": 6}} returns True; database state: {"A": {"B": 9, "C": 6}} returns False; field "C" in record "A" currently has a value of 6, so the operation is ignored returns True; database state: {"A": {"B": 9}} returns None; field "C" in record "A" was previously deleted returns 9